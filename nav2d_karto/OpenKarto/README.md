# OpenKarto
=========

OpenKarto GraphSLAM library by "SRI International"

## Karto中边的建立

1. 根据当前帧与前一帧的间隔，包括角度和距离，判断是否建立为关键帧，非关键帧直接丢弃；
2. 根据odometry信息获取初始位姿
3. scan-to-map，将当前帧与当前时空相邻的帧集合组成的local map进行匹配，在当前帧位姿搜索空间中响应值最高的匹配位姿作为当前帧位姿。这里，并不是所有local map中的点都可以用来进行scan matching，因为有可能距离较近的帧和当前帧扫描的是一个物体的两面。我们希望匹配的点是当前帧有可能扫描到的点，而处在物体另一面的点是不可能用于当前帧匹配的，因此剔除。

这两步相当于构成了Karto的前端。

Karto中后端BA添加的边包括：
1. 与前一帧的边,相当于odometry
2. 与local map中最近的一帧建立边. 这条边和“1”中的边有什么关系，感觉是重复了。因为2中对应的位姿，本来就是通过矫正odometry的位姿获得的，现在又重复把odometry的位姿加进了BA。我猜测一般而言，local map中最近的一帧就是前一帧，因此实际上1,2步只会添加一条边。
3. 与当前帧的广搜近邻帧的chain，建立边。这里的chain，指的是在搜索到距离当前帧较近的帧之后，把这一帧前后的帧也添加进来，构成一个chain，在这个chain上搜索距离当前帧最近的帧，建立边。这样看起来和第4步（下一步）闭环检测的过程是一样的。
4. 与闭环候选帧中最接近的一帧建立边。

我不太清楚3和4有什么区别。

```cpp
/**
 * 主流程
 * 1、用前一帧优化前后的位姿变换，来校正当前帧优化前的位姿，得到一个初始位姿
 * 2、判断两帧间隔是否足够大，不够大则直接丢弃这一帧
 *    满足一下任意一个条件，返回true，都不满足则返回false
 *    a.第一帧
 *    b.两帧之间时间间隔足够长
 *    c.两帧yaw角差量足够大
 *    d.两帧位置差量足够大
 * 3、基于相关方法的scan-to-map匹配
 *    1) 用前一帧优化前后的位姿变换，来校正当前帧优化前的位姿，得到一个初始位姿
 *    2) 提取局部map中当前帧也可以看到的点，对应栅格设置为占用
 *       剔除相对于当前帧属于物体背面的点，也就是近邻帧与当前帧在物体两面
 *    3) scan-to-map匹配
 *       a. 创建旋转角度-激光点旋转后相对于当前帧位置的偏移量
 *          创建索引表，计算当前帧激光点，在各个旋转角度变换下，新的激光点位置相对于当前帧位置（机器人的位置）的坐标偏移量
 *          不管当前帧在什么位置，只要旋转角度一定，那么坐标偏移量也是确定的。
 *          目的是后面在搜索空间中对当前帧位姿施加不同的x平移、y平移之后再施加一个旋转的操作，不用重新计算每个搜索位置处旋转某个角度之后对应的点坐标，只需要加上对应旋转角度下算好的坐标偏移量即可。
 *       b. 遍历pose搜索空间计算响应值     
 *          i. 当前帧激光点集合在某个pose变换下得到新的位置，统计在局部map栅格中这些新位置处占用的数量，占用越多响应值越高，表示匹配越好
 *          ii. 惩罚一下搜索偏移量，越远响应值折扣越多（当前帧搜索距离、角度偏移）
 *       c. 找到响应值最大的pose，如果有多个最佳响应pose，那么对pose求个均值，得到最终pose
 *       d. 计算位姿的协方差
 *    4) 如果响应值是0，没匹配上，扩大角度搜索范围，增加20°、40°、60°，再执行一次scan-to-map匹配
 *    5) 在scan-to-map优化之后的位姿基础上，再缩小搜索空间优化一次，搜索范围减半，角度区间减半，执行scan-to-map匹配
 * 4、构建BA图的顶点、边
 *    1) 与前一帧建立一条边
 *    2) 在局部map帧集合中选取与当前帧最接近的一帧，建立边
 *    3) 在相邻帧的chain中取与当前帧最接近的一帧，建立边
 *       a. 在顶点图中广搜找当前帧的相邻帧，然后对每个相邻帧截取前后时间范围内、且距离小于阈值的一段帧集合（称为chain）
 *       b. 用当前帧与chain进行scan-to-map匹配
 *       c. 如果匹配较好，在chain里面选最近一帧，建立边
 *       d. 对所有数量足够的chain执行前面2、3步
 *       注：相当于当前帧跟比较近，但又没有直接关系的帧（时间上相邻帧，局部匹配帧，闭环帧）建立边
 *     如果闭环成功，也会添加一条边。（注：不在这个方法里面）
 *     4) 最后设置当前帧pose为第3步中计算得到的优化pose集合（包含当前帧pose）的均值
 * 5、添加一帧数据并更新局部map，维护当前帧时空维度上临近的帧集合
 * 6、闭环检测
 *     1) 遍历所有历史帧，提取候选闭环帧集合
 *         a. 在已构造的顶点图中，广搜找与当前顶点帧临近的所有顶点帧，记为临近帧集合
 *         b. 按时序遍历所有历史帧，距离够近的帧加入候选闭环集合，一旦发现一帧在临近帧集合中，清空候选闭环集合，接着往下找
 *         c. 直到距离超过阈值，如果候选闭环集合数量够多，认为合格
 *     2) 当前帧与候选闭环帧集合，执行scan-to-map匹配
 *     3) 如果响应够大，方差够小，执行二次scan-to-map匹配
 *     4) 如果确认闭环，在候选闭环帧集合中选取与当前帧最接近的一帧，建立边，同时更新当前帧位姿
 *     5) 循环提取下一个闭环候选帧集合，寻找闭环
 * 7、找到闭环，则执行BA图优化，更新所有顶点位姿
 */
```
